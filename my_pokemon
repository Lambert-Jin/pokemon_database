#! /usr/bin/env python3


"""
COMP3311
23T1
Assignment 2
Pokemon Database

Written by: <YOUR NAME HERE> <YOUR STUDENT ID HERE>
Written on: <DATE HERE>

My Pokemon

Create your very own Pokemon
"""


import sys
import psycopg2
import helpers
from random import Random
from typing import Tuple


### Constants
USAGE = f"Usage: {sys.argv[0]} <Seed>"


### Globals
db = None
Seed = None
rng = None


### Command-line args
if len(sys.argv) != 2:
    print(USAGE, file=sys.stderr)
Seed = int(sys.argv[1]) # read the seed from the command line
rng  = Random(Seed)     # set the seed for the python random number generator
rseed = str(rng.random())

# `rng` is a python Random number generator
# `rng.random()` returns a random float between 0 and 1
# `rng.randint(a, b)` returns a random integer between a and b (inclusive)

# `SELECT setseed(seed);` sets the postgres random seed to `seed`
# `SELECT * FROM Table ORDER BY random() LIMIT 5;` gives 5 random rows from the table `Table`
# `SELECT setseed(seed);` should be used once, before any calls to random(), with the a random number generated by `rng.random()`

def menu(items: list[str]) -> int:
    """
    Given a list of strings,
    print a numbered menu
    and return the user's selection.
    """
    padding = len(str(len(items)))
    print(f"Select an option from the menu below by entering its number:")
    for i, item in enumerate(items):
        print(f"{i+1:{padding}}) {item}")
    ret = int(input("> Selection: ")) - 1
    if not sys.stdin.isatty():
        print(f"{ret+1}")
    print()
    return ret
    
random_setup = """
select setseed(%s)
"""    
    

    







def select_game() -> str:
    game_query = """
    SELECT name
    FROM Games
    ORDER BY random()
    LIMIT 10
    """    
    cur = db.cursor()
    cur.execute(random_setup, [rseed])
    cur.execute(game_query, [])
    games = cur.fetchall()
    menu_games = [game[0] for game in games]
    user_input = menu(menu_games)
    return menu_games[user_input]

def select_pokemon(game_name: str) -> Tuple[int, str]:
    pokemon_query = """
    SELECT P.name
    FROM Pokemon AS P
    JOIN Pokedex AS PD ON P.ID = PD.National_ID
    JOIN Games AS G ON PD.Game = G.ID
    WHERE G.name = %s
    ORDER BY random()
    LIMIT 10
    """
    cur = db.cursor()
    cur.execute(pokemon_query, [game_name])
    pokemons = cur.fetchall()
    menu_pokemons = [pokemon[0] for pokemon in pokemons]
    user_input = menu(menu_pokemons)
    return menu_pokemons[user_input]


def select_ability(pokemon_name: str) -> str:
    ability_query = """
    SELECT A.name
    FROM Abilities AS A
    JOIN Knowable_Abilities AS KA ON A.ID = KA.Knows
    JOIN Pokemon AS P ON KA.Known_By = P.ID
    WHERE P.name = %s
    ORDER BY A.ID
    """
    cur = db.cursor()
    cur.execute(ability_query, [pokemon_name])
    abilities = cur.fetchall()
    if abilities:
        menu_abilities = [ability[0] for ability in abilities]
        user_input = menu(menu_abilities)
        return menu_abilities[user_input]
    
    return None


def select_moves(pokemon_name: str, game_name: str) -> str:
    move_query = """
    SELECT distinct M.ID, M.NAME
    FROM Moves M
    JOIN Learnable_Moves LM ON LM.Learns = M.ID
    JOIN Requirements R ON R.ID = LM.Learnt_When
    JOIN Pokemon p ON LM.Learnt_By = p.id
    JOIN Games g on LM.Learnt_In = g.id
    WHERE p.name = %s AND g.name = %s AND R.Assertion LIKE 'Level:%%'
    ORDER BY M.ID
    """
    cur = db.cursor()
    cur.execute(move_query, (pokemon_name, game_name))
    moves = cur.fetchall()
    menu_moves = [f"{move[1]}" for move in moves]
    
    selected_moves = []
    max_moves = 4 if len(moves) >= 4 else len(moves)

    for i in range(max_moves):
        user_input = menu(menu_moves)
        selected_move = menu_moves[user_input]
        selected_moves.append(selected_move)
        menu_moves.pop(user_input)

    return selected_moves


    
def main():
    selected_game = select_game()
    selected_pokemon = select_pokemon(selected_game)
    selected_ability = select_ability(selected_pokemon)
    selected_moves = select_moves(selected_pokemon, selected_game)
    print(f"Here is your new Pokemon (from Pokemon {selected_game}):")
    print()

    cur = db.cursor()
    pokemon_info_query = """
    SELECT P.Name, P.Species, T1.Name, T2.Name, PD.Regional_ID, PD.National_ID
    FROM Pokemon P
    JOIN Types T1 ON P.first_type  = T1.ID
    left JOIN Types T2 ON P.second_type = T2.ID
    JOIN Pokedex PD ON P.ID = PD.National_ID
	join games g ON g.id = PD.game
    WHERE P.Name = %s and g.name = %s
    """
    cur.execute(pokemon_info_query, (selected_pokemon, selected_game))
    pokemon_info = cur.fetchone()
    pokemon_info = list(pokemon_info)
    pokemon_info[5] = pokemon_info[5].strip("()")
    pokemon_info[5] = pokemon_info[5].split(',')
    pokemon_info[5] = tuple(pokemon_info[5])

    # pokemon_info[5] = ast.literal_eval(pokemon_info[5])
    pokemon_info = tuple(pokemon_info)

    # Print the Pokemon's information
    print(f"Name: {pokemon_info[0]}")
    print(f"Species: {pokemon_info[1]}")
    if pokemon_info[3] == None:
        print(f"Type: {pokemon_info[2]}")
    else:
        print(f"Type: {pokemon_info[2]} + {pokemon_info[3]}")

    print(f"Pokedex Number: {pokemon_info[4]} ({pokemon_info[5][0]})") 
    print()
    print(f"Ability: {selected_ability}")
    print()
    print(f"Moves:")

    for move in selected_moves:
        move_info_query = """
        SELECT M.Name, T.Name, M.Category, M.Power, M.Accuracy
        FROM Moves M
        JOIN Types T ON M.Of_Type = T.ID
        WHERE M.Name = %s
        """
        cur.execute(move_info_query, [move])
        move_info = cur.fetchone()

        print(f"\t{move_info[0]:<12} [{move_info[1]}]\t(Category: {move_info[2]}, Power: {move_info[3]}, Accuracy: {move_info[4]})")

    

if __name__ == '__main__':
    try:
        db = psycopg2.connect(dbname="ass2")
        main()
    except psycopg2.Error as err:
        print("DB error: ", err)
    except Exception as err:
        print("Internal Error: ", err)
        raise err
    finally:
        if db is not None:
            db.close()
    sys.exit(0)
